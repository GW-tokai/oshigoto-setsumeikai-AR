<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="robots" content="noindex, nofollow, noarchive">
    <meta name="theme-color" content="#c7e5f6">

    <title>ã‚ã‚ŠãŒã¨ã€œã€œã€œã€œã€œã€œï¼</title>

    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas { display: block; }
      #secretMessage {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        text-align: center;  /* ä¸­å¤®æƒãˆ */
        width: auto;
        font-size: 24px;
        font-weight: bold;
        color: red;
        background: rgba(242, 230, 230, 0.8);
        padding: 8px 8px;
        border-radius: 8px;
        display: none;
        z-index: 10;
      }
    </style>
  </head>

  <body>
    <a-scene
      embedded
      arjs="sourceType: webcam; debugUIEnabled: false;"
      renderer="logarithmicDepthBuffer: true;"
    >
      <a-marker type="pattern" url="pattern.patt">
        <!-- scaleã§ã‚µã‚¤ã‚ºå¤‰æ›´å¯èƒ½ÃŸ -->
        <a-entity id="group-container" position="0 0 0" scale="0.25 0.25 0.25"></a-entity>
      </a-marker>

      <a-entity camera></a-entity>
    </a-scene>

    <div id="secretMessage"></div>

    <script>

      class ModelManager {
        constructor(clock, n) {
          this.clock = clock;
          this.n = n;
          this.currentType = 0;
          this.transition = null;
        }

        getCurrentParams() {
          return getModelParams(this.currentType);
        }

        requestNext() {
          if (this.transition) return false;

          const oldType = this.currentType;
          this.currentType = (this.currentType + 1) % this.n;
          this.transition = {
            startTime: this.clock.getElapsedTime(),
            duration: 1.2,
            from: getModelParams(oldType),
            to: getModelParams(this.currentType)
          };
          return true;
        }

        update() {
          if (!this.transition) {
            return { from: null, to: this.getCurrentParams(), progress: 1 };
          }
          const now = this.clock.getElapsedTime();
          const p = Math.min((now - this.transition.startTime) / this.transition.duration, 1);
          if (p >= 1) {
            const finalParams = this.transition.to;
            this.transition = null;
            return { from: null, to: finalParams, progress: 1 };
          }
          return { from: this.transition.from, to: this.transition.to, progress: p };
        }
      }

      const secretMessages = [
        "ã‚ãƒ¼ã„ã‚ãƒ¼ã„ï¼ï¼âœ¨",
        "æ¥½ã—ã‚“ã§ãã‚ŒãŸã‹ãªï¼Ÿ",
        "ã‚ã£ï¼",
        "ãŠãµã£ï¼",
        "ã‚®ãƒ£ãƒ¼ãƒ¼ãƒ¼ãƒ¼ï¼",
        "ãƒãƒ¬ãŸï¼",
        "ã‚ãã°ã‚Œã¦ã‚‹ï¼Ÿ",
        "ã‚ã€ã‚ã‚ŠãŒã¨ï¼",
        "ãƒšãƒ³ã‚®ãƒ³ã ãœï¼",
        "ã´ã‚‡ã“ã£ï¼",
        "è¦‹ã¡ã‚ƒã£ãŸï¼Ÿ",
        "ã©ã‚„ã£ï¼",
        "ã†ã²ã‚‡ãƒ¼ï¼",
        "æŠ¼ã—ãŸãªï¼ï¼Ÿ",
        "ã³ã£ãã‚Šã—ãŸï¼Ÿ",
        "ã‚„ã£ã»ãƒ¼ï¼",
        "ãƒ’ãƒ£ãƒƒãƒãƒ¼ï¼",
        "ãƒšãƒ³ãƒšãƒ³ï¼",
        "ã™ã”ã„ï¼ï¼Ÿ",
        "ã‚„ã‚‹ã‚„ã‚“ï¼",
        "ãŠãŠã£ï¼",
        "ã¡ã‚‡ã£ï¼ï¼Ÿ",
        "ã«ã¸ã¸ã€œ",
        "è¦‹ã£ã¦ã‚‹ã€œï¼Ÿ",
        "ãŠã‰ã€œï¼ï¼Ÿ",
        "ã‚ºã‚³ãƒ¼ãƒƒ",
        "ãã‚ƒã£ï¼",
        "ãˆã£ã¸ã‚“ï¼",
        "ãµãµãµã€œã‚“â™ª",
        "ãŠãƒ¼ã„ï¼",
        "ã‚ã£ã—ã‚‡ã„ï¼",
        "ãŠã‰ãŠï¼ï¼Ÿ",
        "ã©ã†ã‚‚ãƒ¼ï¼",
        "ã¤ã‹ã‚Œã¦ããŸ",
        "ã¾ã ã¾ã ï¼",
        "ãŠãªã‹ã™ã„ãŸ",
        "ã²ã¿ã¤ã ã‚ˆï¼",
        "è€³ã®ã‚ˆã†ã§è€³ã˜ã‚ƒãªã„ï¼",
        "å¤‰ã‚ã£ã¦ã‚‹ã­ã¨è¨€ã‚ã‚Œã¾ã™",
        "ãƒšãƒ³ã‚®ãƒ³ãƒ€ãƒ³ã‚¹ï¼",
        "ãƒãƒ§ã‚³é£Ÿã¹ãŸã„",
        "ã­ã‚€ã„...",
        "ã‚ˆã£ã—ã‚ƒãƒ¼ï¼",
        "ã¸ã¸ã£ï¼",
        "ãã‚‹ãã‚‹ã€œ",
        "ã‚·ãƒ£ã‚±ã¡ã‚‡ã†ã ã„",
        "è¦‹ã¤ã‹ã£ã¡ã‚ƒã£ãŸ",
        "ã¦ã¸ãºã‚",
        "ã‚ˆãæ¥ãŸã­ï¼",
        "ãªã‹ã‚ˆã—ï¼",
        "ã†ã‡ãƒ¼ã„ï¼",
        "ãƒ ãƒ‹ãƒ ãƒ‹ã€œ",
        "ã‚¸ãƒ£ãƒ³ãƒ—ï¼",
        "ãƒœãƒ¨ãƒ¨ãƒ¼ãƒ³ï¼",
        "ãƒ‰ãƒ¤é¡”",
        "ã‚¦ã‚±ã‚‹ã€œ",
        "ã„ãˆãƒ¼ã„ï¼",
        "ã‚¬ã‚ªãƒ¼ãƒƒï¼ï¼Ÿ",
        "ãã™ãã£ãŸã„ï¼",
        "ã‚¿ãƒƒãƒã—ãŸã­ï¼Ÿ",
        "ã¬ã‚‹ã£ã¨ç™»å ´",
        "ã†ã¾ãã§ããŸï¼Ÿ",
        "æ¥½ã—ã‚ãŸã‹ã„ï¼Ÿ",
        "ã™ã¹ã£ã¡ã‚ƒã£ãŸ",
        "å†·ãŸã„ã‚‚ã®å¤§å¥½ãï¼",
        "ãã¿ã‚‚ã‚„ã‚‹ï¼Ÿ",
        "ãƒ¢ãƒ•ãƒ¢ãƒ•ã€œ",
        "æ°·ãã ã•ã„ï¼",
        "ãã§ã€œã‚“",
        "ãµã‚ãµã‚ã€œ",
        "ãªã«ãã‚Œï¼ï¼Ÿ",
        "ãŠãªã‹ãƒãƒ³ï¼",
        "æ°´æµ´ã³ã—ãŸã„ã€œ",
        "ã“ã“ã©ã“ï¼Ÿ",
        "ãƒ•ãƒªãƒ¼ãƒ€ãƒ ï¼",
        "ã™ãã‹ã‚‚ï¼",
        "ã‚¹ã‚±ãƒ¼ãƒˆå¾—æ„ï¼",
        "ã¤ã‚‹ã‚“ã£",
        "ã²ã‚ƒã£ã“ã„ï¼",
        "ã¼ãå°ã•ã„ï¼Ÿ",
        "ã‚·ãƒ£ã‚­ãƒ¼ãƒ³ï¼",
        "ã´ã‚ˆã´ã‚ˆï¼Ÿ",
        "ã¨ã‚Šã‚ãˆãšã‚¿ãƒƒãƒ—",
        "ã—ã‚ƒã‚‰ã‚“ã‚‰ã€œ",
        "ã”ã‚ã‚“ã”ã‚ã‚“",
        "ã´ã£ãŸã‚“ã“",
        "ã»ã‚‰ã­ï¼",
        "ã¾ã˜ã‹ï¼ï¼Ÿ",
        "ã‚¢ãƒãƒï¼",
        "ã„ã¾ã®è¦‹ãŸï¼Ÿ",
        "ã‚°ãƒ«ã‚°ãƒ«ã€œ",
        "ã¯ã—ã‚ƒãã™ããŸ",
        "ã‚‚ã†1å›ï¼",
        "ãƒ‘ã‚¿ãƒ‘ã‚¿ã€œ",
        "ã™ãƒ¼ã„ã™ã„",
        "ã¤ã‚“ã¤ã‚“",
        "ãã‚…ã‚‹ã‚‹ã‚“",
        "ãŠã•ã‹ãªã€œğŸŸ",
        "ã‚‚ã£ãµã‚“",
        "ã³ã‚ˆãƒ¼ã‚“",
        "ã‚„ã‚‹ã…ï¼",
        "ã‚ã¯ã¯ï¼",
      ];

      // ãƒ¢ãƒ‡ãƒ«ç¨®é¡
      const ModelType = {
        DEFAULT: 0, // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
        M: 1        // Mã•ã‚“åˆ¶ä½œ
      };

      // ã‚¸ãƒ£ãƒ³ãƒ—ãƒ‘ã‚¿ãƒ¼ãƒ³
      const JumpPattern = {
        NONE: 0,       // ã‚¸ãƒ£ãƒ³ãƒ—ã—ãªã„
        SIMPLE: 1,     // ã‚·ãƒ³ãƒ—ãƒ«
        FLAPPING: 2,   // è¶³ã‚’ã°ãŸã¤ã‹ã›ã‚‹
        FLAPPING_K: 3  // è¶³ã‚’ã°ãŸã¤ã‹ã›ã‚‹ï¼ˆKãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼‰
      };

      // éš ã—æ–‡å­—ã®è¡¨ç¤ºå ´æ‰€
      const SecretMessageArea = {
        NONE: 0,       // ä¸Šã«éš ã—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        SIGNBOARD: 1,  // çœ‹æ¿
        TOP: 2         // ç”»é¢ä¸Šéƒ¨
      };

      let modelType = ModelType.DEFAULT;
      const jumpPattern = JumpPattern.FLAPPING;
      const secretMessageArea = SecretMessageArea.SIGNBOARD;

      const clock = new THREE.Clock();
      const modelTypeMax = Object.keys(ModelType).length; // ãƒ¢ãƒ‡ãƒ«ã®ç·æ•°
      const modelManager = new ModelManager(clock, modelTypeMax);

      /**
       * æŒ‡å®šãƒ†ã‚­ã‚¹ãƒˆã®ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½œæˆã—ã€çœ‹æ¿ç”¨ã®ãƒãƒ†ãƒªã‚¢ãƒ«ã«ä½¿ç”¨ã™ã‚‹
       * @param {string} text - çœ‹æ¿ã«è¡¨ç¤ºã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
       * @returns {THREE.CanvasTexture} ã‚­ãƒ£ãƒ³ãƒã‚¹ã‹ã‚‰ç”Ÿæˆã—ãŸãƒ†ã‚¯ã‚¹ãƒãƒ£
       */
      function createSignTexture(text) {
        const canvas = document.createElement('canvas');
        canvas.width = 600;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');

        // èƒŒæ™¯è‰² - è–„ã„ã‚¯ãƒªãƒ¼ãƒ è‰²
        ctx.fillStyle = '#fff8dc';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // æ–‡å­—ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®šï¼ˆãƒ¡ã‚¤ãƒªã‚ªãƒ»ãƒœãƒ¼ãƒ«ãƒ‰ãƒ»48pxï¼‰
        ctx.font = 'bold 48px "ãƒ¡ã‚¤ãƒªã‚ª", sans-serif';
        ctx.fillStyle = '#222222'; // æ–‡å­—è‰²ï¼ˆæ¿ƒã„ã‚°ãƒ¬ãƒ¼ï¼‰
        ctx.textBaseline = 'middle';

        const paddingX = 40;
        const x = paddingX + (canvas.width - paddingX * 2) / 2;

        ctx.textAlign = 'center';
        ctx.fillText(text, x, canvas.height / 2);

        // CanvasTextureåŒ–ã—ã¦Three.jsã§åˆ©ç”¨å¯èƒ½ã«ã™ã‚‹
        return new THREE.CanvasTexture(canvas);
      }

      function updateSignText() {
        const ramdomIndex = Math.floor(Math.random() * secretMessages.length);
        const randomSignText = secretMessages[ramdomIndex];

        const newTexture = createSignTexture(randomSignText);
        newTexture.needsUpdate = true; // æ˜ç¤ºçš„ãªæ›´æ–°ã‚’ä¿ƒã™
        sign.material.map = newTexture;
        sign.material.needsUpdate = true; // ãƒãƒ†ãƒªã‚¢ãƒ«æ›´æ–°ã‚‚æ˜ç¤º
      }

      function createHitbox() {
        const hitboxMat = new THREE.MeshBasicMaterial({ visible: false }); // è¦‹ãˆãªã„ãƒãƒ†ãƒªã‚¢ãƒ«
        /*const hitboxMat = new THREE.MeshBasicMaterial({
            color: 0xff0000, // èµ¤è‰²ã§å¯è¦–åŒ–
            wireframe: true, // ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ è¡¨ç¤º
            transparent: true,
            opacity: 0.5     // åŠé€æ˜
        });
        */

        // unit ãƒœãƒƒã‚¯ã‚¹ï¼ˆå¾Œã§ scale ã§åˆã‚ã›ã‚‹ï¼‰
        const hitbox = new THREE.Mesh(new THREE.BoxGeometry(3,5.2,3), hitboxMat);
        return hitbox;
      }

      /**
       * ãƒšãƒ³ã‚®ãƒ³ã®ä¸¡è¶³ã‚’ã¾ã¨ã‚ã¦ç”Ÿæˆã—ã¾ã™ã€‚
       *
       * @param {THREE.BufferGeometry} geometry - å††éŒã‚¸ã‚ªãƒ¡ãƒˆãƒªï¼ˆæŒ‡ã®å½¢ï¼‰
       * @param {THREE.Material} material - ã‚ªãƒ¬ãƒ³ã‚¸è‰²ãƒãƒ†ãƒªã‚¢ãƒ«
       * @param {number} spreadX - è¶³ã®æ¨ªæ–¹å‘ã®é–‹ãè·é›¢ï¼ˆÂ±ã§æŒ¯ã‚Šåˆ†ã‘ï¼‰
       * @returns {THREE.Group} ä¸¡è¶³ï¼ˆå·¦ãƒ»å³ï¼‰ã‚’å«ã‚“ã ã‚°ãƒ«ãƒ¼ãƒ—
       */
      function createFeet(geometry, material, spreadX = 0.4) {
        const group = new THREE.Group();

        // å††éŒã®é«˜ã•ã¨åº•é¢åŠå¾„ã‚’å–å¾—ï¼ˆgeometry.parametersã«ã‚ã‚‹ã¯ãšï¼‰
        const { radius, height } = geometry.parameters;

        // å††éŒã®æ¯ç·šè§’åº¦ï¼ˆr/hã®ã‚¢ãƒ¼ã‚¯ã‚¿ãƒ³ã‚¸ã‚§ãƒ³ãƒˆï¼‰
        const slopeAngle = Math.atan(radius / height);

        const positions = [
          { baseX: -spreadX }, // å·¦è¶³
          { baseX: spreadX }  // å³è¶³
        ];

        for (const { baseX } of positions) {
          const footGroup = new THREE.Group();

          // ä¸­å¤®
          const center = new THREE.Mesh(geometry, material);
          center.scale.set(1.0, 2.6, 0.6);
          center.rotation.x = Math.PI / 2 + Math.atan((radius * center.scale.x) / (height * center.scale.y));

          footGroup.add(center);

          // å·¦æŒ‡
          const left = center.clone();
          left.scale.y = 2.2;
          left.position.x = -0.1;
          left.rotation.z = 0.25;
          left.rotation.x = Math.PI / 2 + Math.atan((radius * left.scale.x) / (height * left.scale.y));
          footGroup.add(left);

          // å³æŒ‡
          const right = left.clone();
          right.position.x *= -1;
          right.rotation.z *= -1;
          footGroup.add(right);

          footGroup.position.set(baseX, -1.4, 0.4);
          group.add(footGroup);
        }

        return group;
      }


      function createEyes(params = {}) {
        const group = new THREE.Group();

        // ãƒãƒ†ãƒªã‚¢ãƒ«é¡ï¼ˆé»’ç›®ã¨ç™½ç›®ï¼‰
        const blackMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6, metalness: 0.1 });
        const scleraMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1, metalness: 0 });
        const irisMat = blackMat;

        // ã‚¸ã‚ªãƒ¡ãƒˆãƒª
        const eyeBlackGeom = new THREE.SphereGeometry(0.07, 16, 16);
        const eyeWhiteGeom = new THREE.SphereGeometry(0.03, 16, 16);

        // å³ç›®ç™½ç›®
        const scleraRight = new THREE.Mesh(eyeBlackGeom, scleraMat);
        scleraRight.position.set(-0.18, 1.2, 0.55);
        group.add(scleraRight);

        // å³é»’ç›®
        const irisRight = new THREE.Mesh(eyeBlackGeom, irisMat);
        irisRight.position.set(-0.18002, 1.201, 0.5508);
        irisRight.scale.set(0.97, 0.975, 1);
        group.add(irisRight);

        // å·¦ç›®ç™½ç›®ï¼ˆå³ç›®ç™½ç›®ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦Xåè»¢ï¼‰
        const scleraLeft = scleraRight.clone();
        scleraLeft.position.x *= -1;
        group.add(scleraLeft);

        // å·¦ç›®é»’ç›®ï¼ˆå³é»’ç›®ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦Xåè»¢ï¼‰
        const irisLeft = irisRight.clone();
        irisLeft.position.x *= -1;
        group.add(irisLeft);

        // ç›®ã®ã‚°ãƒ«ãƒ¼ãƒ—ã«åå‰ã‚’ä»˜ã‘ã¦è¿”ã™
        group.scleraRight = scleraRight;
        group.irisRight   = irisRight;
        group.scleraLeft  = scleraLeft;
        group.irisLeft    = irisLeft;

        return group;
      }


      /**
       * ãƒšãƒ³ã‚®ãƒ³ã®3Dãƒ¢ãƒ‡ãƒ«ã‚’ä½œæˆã—ã¦è¿”ã™
       * ã‚¢ãƒ‹ãƒ¡ãƒãƒƒã‚¯ã«è¦‹ãˆã‚‹ã‚ˆã†å½¢çŠ¶ãƒ»è‰²å‘³ãƒ»ã‚µã‚¤ã‚ºã‚’èª¿æ•´
       * @returns {THREE.Group} ãƒšãƒ³ã‚®ãƒ³ã‚°ãƒ«ãƒ¼ãƒ—ãƒ¡ãƒƒã‚·ãƒ¥
       */
      function createPenguin() {
        const group = new THREE.Group();

        // ãƒãƒ†ãƒªã‚¢ãƒ«å®šç¾© - å…‰æ²¢æ§ãˆã‚ã§æŸ”ã‚‰ã‹ã„ã‚¢ãƒ‹ãƒ¡é¢¨
        const blackMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.6, metalness: 0.1 });
        const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.7, metalness: 0.0 });
        const orangeMat = new THREE.MeshStandardMaterial({ color: 0xffa500, roughness: 0.5, metalness: 0.1 });

        // èƒ´ä½“ - å°‘ã—ç¸¦é•·ã®æ¥•å††çƒ
        const bodyGeom = new THREE.SphereGeometry(1, 48, 32);
        const body = new THREE.Mesh(bodyGeom, blackMat);
        body.scale.set(1.1, 1.5, 0.9);
        group.add(body);
        group.body = body; // èƒ´ä½“ã®å‚ç…§ã‚’ä¿æŒ

        // ãŠè…¹ - å¤§ããã¦ä¸¸ã„æ¥•å††çƒï¼ˆç™½ï¼‰
        const bellyGeom = new THREE.SphereGeometry(0.7, 48, 32);
        const belly = new THREE.Mesh(bellyGeom, whiteMat);
        belly.position.set(0, -0.1, 0.45);
        belly.scale.set(1.0, 1.45, 0.95);
        group.add(belly);
        group.belly = belly; // ãŠè…¹ã®å‚ç…§ã‚’ä¿æŒ

        // ãã¡ã°ã— - ä¸¸ã¿ã®ã‚ã‚‹å††éŒå½¢ã€å‰æ–¹ã«é…ç½®
        const beakGeom = new THREE.ConeGeometry(0.13, 0.35, 16);
        const beak = new THREE.Mesh(beakGeom, orangeMat);
        beak.position.set(0, 0.95, 0.8);
        beak.rotation.x = Math.PI / 1.8; // å‰å‘ãã«å›è»¢
        // æ¨ªã«æ‰å¹³åŒ–ï¼ˆXæ–¹å‘æ‹¡å¤§ã€Yæ–¹å‘ç¸®å°ï¼‰// æ¨ªã¨å¥¥è¡Œãã‚’èª¿æ•´ã—ã¦å…ˆç«¯ã‚‚æ‰å¹³ã«ã™ã‚‹
        beak.scale.set(2.0, 0.7, 0.9); // X=æ¨ªå¹…åºƒã’ã‚‹ã€Y=ç¸¦æ–¹å‘ç¸®ã‚ã‚‹ã€Z=å¥¥è¡Œãç¸®ã‚ã‚‹
        group.add(beak);
        group.beak = beak; // ãã¡ã°ã—ã®å‚ç…§ã‚’ä¿æŒ

        const eyes = createEyes();
        group.add(eyes);
        group.eyes = eyes; // ç›®ã®å‚ç…§ã‚’ä¿æŒ

        // ç¿¼ - ä¸¸ã¿ãŒã‚ã‚Šå¤ªã‚ã«ã—ã¦å¯æ„›ãè¡¨ç¾
        const wingGeom = new THREE.SphereGeometry(0.5, 16, 16);
        const wingLeft = new THREE.Mesh(wingGeom, blackMat);
        wingLeft.scale.set(0.5, 1.8, 0.15);
        wingLeft.position.set(-1.05, 1.3, 0.4);
        wingLeft.rotation.z = Math.PI / 10;
        group.add(wingLeft);

        const wingRight = wingLeft.clone();
        wingRight.position.x = 1.05;
        wingRight.rotation.z = -Math.PI / 10;
        group.add(wingRight);

         // ç¿¼ã®å‚ç…§ã‚’ä¿æŒ
        group.wingLeft = wingLeft;
        group.wingRight = wingRight;

        // è¶³ - çŸ­ãã¦å¤ªã„ä¸‰è§’éŒå½¢ã€ä¸Šä¸‹é€†ã•ã¾ã«ã—ã¦ã‚¢ãƒ‹ãƒ¡èª¿ã«
        const footGeom = new THREE.ConeGeometry(0.13, 0.35, 16);

        const feet = createFeet(footGeom, orangeMat, 0.4); // â† é–‹ãå…·åˆã¯ spreadXï¼ˆÂ±0.4ï¼‰
        group.add(feet);
        group.feet = feet; // è¶³ã®å‚ç…§ã‚’ä¿æŒ

        return group;
      }

      const penguin = createPenguin();

      const signTex = createSignTexture("æ¥ã¦ãã‚Œã¦ã‚ã‚ŠãŒã¨ã­â¤ï¸");
      const signMat = new THREE.MeshStandardMaterial({map: signTex, side: THREE.DoubleSide});
      const signGeom = new THREE.PlaneGeometry(2.5, 1.25);
      sign = new THREE.Mesh(signGeom, signMat);
      sign.position.set(0, 2.5, 0.48);
      penguin.add(sign);

      const hitbox = createHitbox();
      hitbox.position.set(0, 0.8, 0); // ãƒšãƒ³ã‚®ãƒ³ä¸­å¿ƒã«åˆã‚ã›ã‚‹
      penguin.add(hitbox);
      penguin.hitbox = hitbox;

      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();
      const secretDiv = document.getElementById('secretMessage');

      const sceneEl = document.querySelector('a-scene');
      const markerEl = document.querySelector('a-marker');

      window.addEventListener('pointerdown', (event) => {
        // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã®ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ä½ç½®/ã‚µã‚¤ã‚ºã§æ­£è¦åŒ–ï¼ˆã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚„CSSæ‹¡å¤§ã«å¯¾å¿œï¼‰
        const canvas = sceneEl.renderer && sceneEl.renderer.domElement ? sceneEl.renderer.domElement : sceneEl.canvas;
        if (!canvas) return;

        function showSecretMessage() {
          const msg = secretMessages[Math.floor(Math.random() * secretMessages.length)];
          secretDiv.textContent = msg;
          secretDiv.style.display = 'block';
          setTimeout(() => {
            secretDiv.style.display = 'none';
          }, 1000);
        }
  
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        // ç¯„å›²å¤–ã‚¯ãƒªãƒƒã‚¯ã¯ç„¡è¦–
        if (x < 0 || y < 0 || x > rect.width || y > rect.height) return;

        pointer.x = (x / rect.width) * 2 - 1;
        pointer.y = - (y / rect.height) * 2 + 1;

        // ãƒãƒ¼ã‚«ãƒ¼ãŒæ¤œå‡ºã•ã‚Œã¦ã„ã‚‹ï¼ˆè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ï¼‰å ´åˆã ã‘ãƒ¬ã‚¤ã‚’é£›ã°ã™
        // a-marker ã® object3D.visible ã¯ AR.js ãŒ on/off ã—ã¦ã„ã‚‹ã¯ãš
        if (!markerEl || !markerEl.object3D || !markerEl.object3D.visible) {
          // ãƒãƒ¼ã‚«ãƒ¼æœªæ¤œå‡º â†’ åå¿œã•ã›ãªã„
          return;
        }

        // ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆå®Ÿè¡Œï¼ˆcamera ã¯ sceneEl.cameraï¼‰
        raycaster.setFromCamera(pointer, sceneEl.camera);
        const target = penguin.hitbox || penguin; // hitbox ãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ã†
        const intersects = raycaster.intersectObject(target, true);

        if (intersects.length === 0) return;

        // äº¤å·®ç‚¹ãŒã‚«ãƒ¡ãƒ©ã®ã€Œå‰æ–¹ã€ã«ã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        const hit = intersects[0];
        const camPos = new THREE.Vector3();
        sceneEl.camera.getWorldPosition(camPos);
        const toPoint = hit.point.clone().sub(camPos);
        const camDir = new THREE.Vector3();
        sceneEl.camera.getWorldDirection(camDir);

        // camDir ã¨ toPoint ã®å†…ç©ãŒæ­£ãªã‚‰å‰æ–¹
        if (camDir.dot(toPoint) <= 0) {
          // å¾Œæ–¹ã®ãƒ’ãƒƒãƒˆï¼ˆå¿µã®ãŸã‚ç„¡è¦–ï¼‰
          return;
        }

        if (modelManager.requestNext()) {
          if (secretMessageArea === SecretMessageArea.SIGNBOARD) {
            // çœ‹æ¿ã®ãƒ†ã‚­ã‚¹ãƒˆæ›´æ–°
            updateSignText();
          } else if (secretMessageArea === SecretMessageArea.TOP) {
            // ç”»é¢ä¸Šéƒ¨ã«éš ã—ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
            showSecretMessage();
          }
        }
      });

      function getModelParams(type) {
        if (type === ModelType.DEFAULT) {
          return {
            bodyScale: new THREE.Vector3(1.1, 1.5, 0.9),
            bellyPos: new THREE.Vector3(0, -0.1, 0.45),
            bellyScale: new THREE.Vector3(1.0, 1.45, 0.95),
            beakPos: new THREE.Vector3(0, 0.95, 0.8),
            beakRotX: Math.PI / 1.8,
            scleraRightPos: new THREE.Vector3(-0.18, 1.2, 0.55),
            scleraLeftPos:  new THREE.Vector3( 0.18, 1.2, 0.55),
            eyeRightPos: new THREE.Vector3(-0.18002, 1.201, 0.5508),
            eyeLeftPos:  new THREE.Vector3( 0.18002, 1.201, 0.5508),
            hitboxSize: new THREE.Vector3(1, 1, 1)
          };
        } else if (type === ModelType.M) {
          return {
            bodyScale: new THREE.Vector3(2.1, 1.5, 1.9),
            bellyPos: new THREE.Vector3(0, -0.1, 1.45),
            bellyScale: new THREE.Vector3(2.0, 1.45, 0.95),
            beakPos: new THREE.Vector3(0, 0.95, 1.6),
            beakRotX: Math.PI / 1.8 - Math.PI/8,
            scleraRightPos: new THREE.Vector3(-0.18, 1.1, 0.55+0.8),
            scleraLeftPos:  new THREE.Vector3( 0.18, 1.1, 0.55+0.8),
            eyeRightPos: new THREE.Vector3(-0.18002, 1.101, 0.5508+0.8),
            eyeLeftPos:  new THREE.Vector3( 0.18002, 1.101, 0.5508+0.8),
            hitboxSize: new THREE.Vector3(1.4, 1, 1.45)
          };
        }
      }

      // A-Frameã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã«ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¿½åŠ 
      const entity = document.querySelector('#group-container');
      entity.object3D.add(penguin);

      // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
      function animate() {
        requestAnimationFrame(animate);

        // æ™‚é–“å–å¾—
        const t = clock.getElapsedTime();

        // ãƒšãƒ³ã‚®ãƒ³ç§»å‹•ï¼ˆä»Šã®æ™‚é–“tï¼‰
        penguin.position.x = Math.sin(t * 0.4) * 1.5 + Math.sin(t * 1.8) * 0.25 + Math.sin(t * 3.2) * 0.1;

        // ä»Šã®å‘ããƒ™ã‚¯ãƒˆãƒ«è¨ˆç®—
        let dx = Math.cos(t * 0.4) + Math.cos(t * 1.8) * 0.2 + Math.cos(t * 3.2) * 0.1;
        let dz = 1.0; // åŸºæº–å‰æ–¹

        penguin.rotation.y = Math.atan2(dx, dz);

        // ãƒ¨ã‚¿ãƒ¨ã‚¿æºã‚Œ
        penguin.rotation.z = Math.sin(t * 4) * 0.04;

        if (jumpPattern !== JumpPattern.NONE && penguin.feet) {
          /// --- ã‚¸ãƒ£ãƒ³ãƒ—ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ --- ///
          // çµŒéæ™‚é–“ t ã‚’ã‚¸ãƒ£ãƒ³ãƒ—ã‚µã‚¤ã‚¯ãƒ«å†…ã®é€²è¡Œåº¦ (0ã€œ1) ã«å¤‰æ›
          const jumpCycle = 1.2; // 1å›ã®ã‚¸ãƒ£ãƒ³ãƒ—æ™‚é–“(ç§’)
          const jumpHeight = 2.2; // ã‚¸ãƒ£ãƒ³ãƒ—ã®é«˜ã•ã‚¹ã‚±ãƒ¼ãƒ«
          let phase = (t % jumpCycle) / jumpCycle; // 0ã€œ1

          // 0ã€œ1ã®phaseã«å¿œã˜ãŸæ”¾ç‰©ç·š: 0ã¨1ã§0ã€é«˜ã•0.5ã§æœ€å¤§1
          let h = 1 - 4 * (phase - 0.5) ** 2;

          // yã®ä½ç½®
          penguin.position.y = 1 + h * jumpHeight;

          if (jumpPattern === JumpPattern.SIMPLE) { // ã‚·ãƒ³ãƒ—ãƒ«
            // è¶³å…¨ä½“ã®ä¸Šä¸‹ç§»å‹•ï¼ˆã—ã‚ƒãŒã‚€ã¨ãè¶³ãŒå°‘ã—æ²ˆã‚€ï¼‰
            penguin.feet.position.y = -0.1 + (0.24 * (1 - h)); 

            // è¶³å…¨ä½“ã®å›è»¢ï¼ˆã—ã‚ƒãŒã‚€ã¨ãã¤ã¾å…ˆã‚’å°‘ã—å‰ã«å‡ºã™ï¼‰
            penguin.feet.rotation.x = -0.1 + 0.4 * h; // hãŒ0ã«è¿‘ã„ã»ã©å‰å‚¾
          } else if (jumpPattern === JumpPattern.FLAPPING) { // ã°ãŸã¤ã
            // è¶³å…¨ä½“ã®ä¸Šä¸‹ç§»å‹•ï¼ˆã—ã‚ƒãŒã‚€ã¨ãè¶³ãŒå°‘ã—æ²ˆã‚€ï¼‰
            penguin.feet.position.y = -0.1 + (0.24 * (1 - h)); 

            // è¶³å…¨ä½“ã®å›è»¢ï¼ˆã—ã‚ƒãŒã‚€ã¨ãã¤ã¾å…ˆã‚’å°‘ã—å‰ã«å‡ºã™ï¼‰
            penguin.feet.rotation.x = -0.1 + 0.4 * h; // hãŒ0ã«è¿‘ã„ã»ã©å‰å‚¾

            // ã‚¸ãƒ£ãƒ³ãƒ—ã®ã—ã‚ƒãŒã¿ã€œä¼¸ã³ã®åŸºæº–å§¿å‹¢
            const baseY = -0.1 + 0.24 * (1 - h);
            const baseRotX = -0.1 + 0.4 * h;

            // è¶³ã‚°ãƒ«ãƒ¼ãƒ—ã®å…¨ä½“ç§»å‹•ã ã‘å…±é€šã§é©ç”¨
            penguin.feet.position.y = baseY;

            // ç©ºä¸­ã«ã„ã‚‹ã‹ã©ã†ã‹
            const inAir = h > 0.1;

            // å·¦å³ã®è¶³ï¼ˆcreateFeetã§2ã¤è¿½åŠ ã•ã‚ŒãŸå­ã‚°ãƒ«ãƒ¼ãƒ—ï¼‰ã‚’å€‹åˆ¥ã«å‡¦ç†
            const leftFoot = penguin.feet.children[0];
            const rightFoot = penguin.feet.children[1];

            // å€‹åˆ¥ã®ãƒã‚¿ã¤ã (å·¦å³ã§ä½ç›¸ã‚’ãšã‚‰ã™)
            const flapAmp = 0.15;
            const flapSpeed = 20; // é«˜é€Ÿã‚µã‚¤ãƒ³æ³¢
            const leftFlap  = inAir ? Math.sin(t * flapSpeed) * flapAmp * h : 0;
            const rightFlap = inAir ? Math.sin(t * flapSpeed + Math.PI/2) * flapAmp * h : 0;

            // è¶³ã®å›è»¢ã‚’é©ç”¨ï¼ˆåŸºæº–å§¿å‹¢ï¼‹ãƒã‚¿ã¤ãï¼‰
            leftFoot.rotation.x  = baseRotX + leftFlap;
            rightFoot.rotation.x = baseRotX + rightFlap;
          } else if (jumpPattern === JumpPattern.FLAPPING_K) { // ã°ãŸã¤ãï¼ˆKãƒãƒ¼ã‚¸ãƒ§ãƒ³ï¼‰
            const feetLeft = penguin.feet.children[0];
            const feetRight = penguin.feet.children[1];

            feetLeft.rotation.x = Math.sin(t * 4.0) * 0.25;
            feetRight.rotation.x = Math.sin(t * -4.0) * 0.25;
          }
          /// -------------------------- ///
        } else {
          penguin.position.y = 1.0 + Math.sin(t * 2.0) * 0.06 + Math.sin(t * 5.0) * 0.02;
        }

        const { from, to, progress } = modelManager.update();

        if (progress < 1 && from) {
          penguin.children[0].scale.lerpVectors(from.bodyScale, to.bodyScale, progress);

          const belly = penguin.belly;
          belly.position.lerpVectors(from.bellyPos, to.bellyPos, progress);
          belly.scale.lerpVectors(from.bellyScale, to.bellyScale, progress);

          const beak = penguin.beak;
          beak.position.lerpVectors(from.beakPos, to.beakPos, progress);
          beak.rotation.x = THREE.MathUtils.lerp(from.beakRotX, to.beakRotX, progress);

          const eyes = penguin.eyes;
          eyes.irisRight.position.lerpVectors(from.eyeRightPos, to.eyeRightPos, progress);
          eyes.irisLeft.position.lerpVectors(from.eyeLeftPos, to.eyeLeftPos, progress);
          eyes.scleraRight.position.lerpVectors(from.scleraRightPos, to.scleraRightPos, progress);
          eyes.scleraLeft.position.lerpVectors(from.scleraLeftPos, to.scleraLeftPos, progress);

          const hitboxSize = new THREE.Vector3().lerpVectors(from.hitboxSize, to.hitboxSize, progress);
          // ãƒ’ãƒƒãƒˆãƒœãƒƒã‚¯ã‚¹ã¯ penguin ã®å­ãªã®ã§ã€local scale ã‚’ç›´æ¥ã‚»ãƒƒãƒˆã™ã‚Œã°OK
          if (penguin.hitbox) {
            penguin.hitbox.scale.copy(hitboxSize);
          }
        } else {
          // é€šå¸¸æ™‚
          const p = to;
          penguin.children[0].scale.copy(p.bodyScale);
          const belly = penguin.belly;
          belly.position.copy(p.bellyPos);
          belly.scale.copy(p.bellyScale);
          const beak = penguin.beak;
          beak.position.copy(p.beakPos);
          beak.rotation.x = p.beakRotX;
          const eyes = penguin.eyes;
          eyes.irisRight.position.copy(p.eyeRightPos);
          eyes.irisLeft.position.copy(p.eyeLeftPos);
          eyes.scleraRight.position.copy(p.scleraRightPos);
          eyes.scleraLeft.position.copy(p.scleraLeftPos);

        }
      }

      animate();
    </script>
  </body>
</html>
